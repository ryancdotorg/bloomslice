; width  1 -  8, n   1 -   20: hash1b
; width  9 - 16, n   1 -   10: hash1s
; width  9 - 16, n  11 -  190: hash2b
; width 17 - 32, n   1 -   45: hash2s
; width 17 - 24, n  46 - 1140: hash3b
; width 25 - 32, n  46 - 4845: hash4b
; width 33 - 48, n   1 -  120: hash3s
; width 33 - 40, n 121 -15504: hash5b
; width 41 - 48, n 121 -38760: hash6b

; in practice, limit number of hashes, since worst case false positive rate
; is 2^(-k) with saturation of 0.5, so more than ~80 is kind of gratuitious

%macro hashns 2-*      ; pseudohash from 16 bit chunks
                       ; registers:
                       ; rsi = input data address
                       ; rdi = bloom filter data address
                       ; rcx = hash mask
                       ; rax = hash value
%assign N %0-1         ; number of short values to be loaded
hash%[N]s%1:           ; label for this hash
  %rotate 1            ; second argument is now %1
  mov ax, [rsi+%1]     ; load the first 16 bits
  %rep %[N]-1          ; loop over the rest of the arguments
    shl rax, 16        ; shift rax left 16 bits to make room for next 16 bits
    %rotate 1          ; next argument is now %1 
    mov ax, [rsi+%1]   ; load next 16 bits
  %endrep              ; everything loaded
  and rax, rcx         ; mask off hash value
%endmacro

%macro hashnb 2-*      ; pseudohash from 8 bit chunks
                       ; registers:
                       ; rsi = input data address
                       ; rdi = bloom filter data address
                       ; rcx = hash mask
                       ; rax = hash value
%assign N %0-1         ; number of byte values to be loaded
hash%[N]b%1:           ; label for this hash
  %rotate 1            ; second argument is now %1
  %if (%[N] & 1) == 0  ; if number of values to be loaded is even...
    mov ah, [rsi+%1]   ; load first 8 bits to bits 48-55
    %rotate 1          ; next argument is now %1
  %endif               ;
  mov al, [rsi+%1]     ; load next 8 bits to bits 56-63
  %rep %[(N-1)/2]      ; loop over each pair of remaining arguments
    shl rax, 16        ; shift rax left 16 bits to make room for next 16 bits
    %rotate 1          ; next argument is now %1
    mov ah, [rsi+%1]   ; load next 8 bits
    %rotate 1          ; next argument is now %1
    mov al, [rsi+%1]   ; load next 8 bits
  %endrep              ; everything loaded
  and rax, rcx         ; mask off hash value
%endmacro

%macro check_bit 0     ; check whether bit rax of the bloom filter is set
  mov   rdx, rax       ; copy hash
  shr   rax, 3         ; byte to check in rax
  and   edx, 7         ; mask off bit to check
  mov    al, [rdi+rax] ; load byte to check from memory
  bt     ax, dx        ; bit test against bloom filter (set carry flag)
  jnc   bloom_miss     ; jump to return a 'miss' if bit isn't set
%endmacro              ; rax and rdx are clobbered

; vim:ai:sw=2:ts=2:et:syntax=nasm:filetype=nasm
